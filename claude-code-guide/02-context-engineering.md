# 02. 上下文工程（Context Engineering）

## 目录
- [2.1 三层记忆架构](#21-三层记忆架构)
- [2.2 上下文自动摘要机制](#22-上下文自动摘要机制)
- [2.3 Token 预算管理](#23-token-预算管理)
- [2.4 无限对话支持](#24-无限对话支持)
- [2.5 上下文管理命令](#25-上下文管理命令)
- [2.6 实践技巧](#26-实践技巧)

---

## 2.1 三层记忆架构

Claude Code 的上下文管理受**认知科学**启发，模拟人类的记忆系统。

### 架构概览

```
┌─────────────────────────────────────────────────────────┐
│          Human-Inspired Memory Architecture              │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  Layer 1: Working Memory (工作记忆 / 短期记忆)           │
│  ┌────────────────────────────────────────────────┐     │
│  │  容量: ~8k tokens (最近的对话)                 │     │
│  │  特点:                                         │     │
│  │  ├─ 极快访问速度 (像 CPU L1 缓存)             │     │
│  │  ├─ 当前任务的活跃信息                         │     │
│  │  ├─ 最近的工具调用结果                         │     │
│  │  └─ 用户最新的指令                             │     │
│  │                                                │     │
│  │  内容示例:                                     │     │
│  │  - 最近 3-5 轮对话                             │     │
│  │  - 当前正在编辑的文件                          │     │
│  │  - 刚执行的 Bash 命令输出                      │     │
│  │  - 活跃的任务状态                              │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Layer 2: Active Context (活跃上下文 / 中期记忆)        │
│  ┌────────────────────────────────────────────────┐     │
│  │  容量: ~80k tokens (语义压缩后的历史)          │     │
│  │  特点:                                         │     │
│  │  ├─ 语义压缩存储 (而非原始文本)                │     │
│  │  ├─ 保留关键决策和重要上下文                   │     │
│  │  ├─ 过滤掉冗余和重复信息                       │     │
│  │  └─ 支持快速检索                               │     │
│  │                                                │     │
│  │  内容示例:                                     │     │
│  │  - 项目架构理解                                │     │
│  │  - 之前做过的重要决策                          │     │
│  │  - 错误和修复历史                              │     │
│  │  - 用户偏好设置                                │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Layer 3: Persistent State (持久化状态 / 长期记忆)      │
│  ┌────────────────────────────────────────────────┐     │
│  │  容量: 无限 (文件系统存储)                     │     │
│  │  特点:                                         │     │
│  │  ├─ 完全持久化到磁盘                           │     │
│  │  ├─ 跨会话访问                                 │     │
│  │  ├─ 结构化存储 (JSON, Markdown)                │     │
│  │  └─ 按需加载到活跃上下文                       │     │
│  │                                                │     │
│  │  内容示例:                                     │     │
│  │  - 任务列表 (~/.claude/tasks/)                │     │
│  │  - 会话历史 (~/.claude/sessions/)             │     │
│  │  - 项目文档 (CLAUDE.md)                       │     │
│  │  - Skills 定义 (.claude/skills/)              │     │
│  │  - MCP 配置 (.claude/mcp.json)                │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 记忆层级交互

```
信息流动方向:

Input (用户请求)
    │
    ↓
┌──────────────────┐
│ Working Memory   │  ← 新信息首先进入
└──────────────────┘
    │
    ↓ (92% 阈值触发)
┌──────────────────┐
│ Compression      │  ← 语义压缩
│ Algorithm        │
└──────────────────┘
    │
    ├─→ 重要信息 → Active Context (保留)
    │
    └─→ 冗余信息 → 丢弃

┌──────────────────┐
│ Active Context   │  ← 压缩后的历史
└──────────────────┘
    │
    ↓ (会话结束或显式保存)
┌──────────────────┐
│ Persistent State │  ← 永久存储
└──────────────────┘

Retrieval (信息检索):

用户查询
    │
    ↓
┌──────────────────┐
│ 1. 搜索 Working  │  ← 最快
│    Memory        │
└──────────────────┘
    │
    ↓ (未找到)
┌──────────────────┐
│ 2. 搜索 Active   │  ← 较快
│    Context       │
└──────────────────┘
    │
    ↓ (未找到)
┌──────────────────┐
│ 3. 加载 Persist  │  ← 最慢但完整
│    State         │
└──────────────────┘
```

### 设计优势

| 方面 | 单层上下文 | 三层记忆架构 |
|-----|-----------|-------------|
| **容量** | 固定 200k tokens | 事实上无限 |
| **访问速度** | 均匀 | 分层优化（快/中/慢）|
| **信息保留** | 达到上限后截断 | 智能压缩 + 持久化 |
| **跨会话** | 不支持 | 完全支持 |
| **成本效率** | 低（重复加载）| 高（按需加载）|

---

## 2.2 上下文自动摘要机制

Claude Code 的核心创新之一是 **92% 智能压缩阈值**。

### 92% 魔法数字的由来

```
上下文窗口状态:

0% ──────────────────────────────────────────── 100%
│                                      ↑        │
│                                      92%      │
│                                      触发     │
│                                      压缩     │
│                                              │
├─────────────────────────────────────┼────────┤
│  安全区域                            │ 危险区 │
│  (正常对话)                          │ (风险) │
└──────────────────────────────────────────────┘

为什么是 92%？

1. 留出响应空间 (8% ≈ 16k tokens)
   - Claude 的响应可能很长
   - 包含代码、解释、工具调用
   - 避免中途截断

2. 压缩需要时间
   - 压缩本身消耗 tokens
   - 需要分析和总结
   - 92% 提供足够缓冲

3. 经验优化
   - 基于实际使用数据
   - 平衡效率和安全性
   - 避免频繁压缩
```

### 压缩算法流程

```
┌─────────────────────────────────────────────────────────┐
│           Context Compaction Algorithm                   │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  Step 1: 触发检测                                        │
│  ┌────────────────────────────────────────────────┐     │
│  │  if (context_usage >= 92% of max_tokens):      │     │
│  │      trigger_compaction()                      │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Step 2: 内容分类                                        │
│  ┌────────────────────────────────────────────────┐     │
│  │  分析当前上下文，分为:                          │     │
│  │                                                │     │
│  │  A. 必须保留 (Critical):                       │     │
│  │     - 用户最近的指令 (最近 3 轮)               │     │
│  │     - 活跃的任务状态                           │     │
│  │     - 当前文件的编辑上下文                     │     │
│  │     - 关键的错误信息                           │     │
│  │                                                │     │
│  │  B. 可以压缩 (Compressible):                   │     │
│  │     - 成功的工具调用历史                       │     │
│  │     - 中间步骤的详细输出                       │     │
│  │     - 重复的信息                               │     │
│  │     - 已完成的任务                             │     │
│  │                                                │     │
│  │  C. 可以丢弃 (Disposable):                     │     │
│  │     - 冗余的文件读取                           │     │
│  │     - 失败的尝试详情                           │     │
│  │     - 临时的调试输出                           │     │
│  │     - 过期的上下文                             │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Step 3: 语义压缩                                        │
│  ┌────────────────────────────────────────────────┐     │
│  │  对 "可压缩" 内容进行智能摘要:                 │     │
│  │                                                │     │
│  │  原始 (5000 tokens):                           │     │
│  │  "读取 auth.ts... 发现问题... 修改...         │     │
│  │   测试失败... 再次修改... 测试成功..."        │     │
│  │                                                │     │
│  │  压缩后 (500 tokens):                          │     │
│  │  "修复了 auth.ts 中的认证逻辑问题，           │     │
│  │   经过 2 次迭代后测试通过"                     │     │
│  │                                                │     │
│  │  压缩比: 10:1                                  │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Step 4: 重构上下文                                      │
│  ┌────────────────────────────────────────────────┐     │
│  │  新的上下文结构:                               │     │
│  │                                                │     │
│  │  ┌──────────────────────────────────────┐     │     │
│  │  │ 系统提示 (System Prompt)             │     │     │
│  │  ├──────────────────────────────────────┤     │     │
│  │  │ 项目上下文 (从 CLAUDE.md 加载)       │     │     │
│  │  ├──────────────────────────────────────┤     │     │
│  │  │ 压缩的历史摘要                       │     │     │
│  │  │ "之前做了什么的简要总结..."          │     │     │
│  │  ├──────────────────────────────────────┤     │     │
│  │  │ 关键决策和错误                       │     │     │
│  │  │ "决定使用 JWT 而非 Session"          │     │     │
│  │  ├──────────────────────────────────────┤     │     │
│  │  │ 活跃的工作记忆 (最近 3-5 轮)         │     │     │
│  │  └──────────────────────────────────────┘     │     │
│  │                                                │     │
│  │  新的 token 使用率: ~45%                       │     │
│  └────────────────────────────────────────────────┘     │
│                          ↓                               │
│  Step 5: 持久化 (可选)                                   │
│  ┌────────────────────────────────────────────────┐     │
│  │  保存会话状态到:                               │     │
│  │  ~/.claude/sessions/{session-id}/               │     │
│  │  ├─ context.json (压缩后的上下文)              │     │
│  │  ├─ tasks.json (任务状态)                      │     │
│  │  └─ metadata.json (会话元数据)                 │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 压缩效果示例

#### 压缩前 (18,000 tokens)

```
User: 实现用户认证功能
Claude: 好的，让我先读取相关文件
[Read tool: src/auth.ts - 2000 tokens]
[Read tool: src/user.ts - 1500 tokens]
[Read tool: package.json - 800 tokens]
Claude: 我发现当前没有认证库，需要安装 jsonwebtoken
[Bash: npm install jsonwebtoken - 1200 tokens output]
Claude: 现在开始实现 JWT 认证
[Write tool: src/auth.ts - 3000 tokens]
Claude: 测试认证功能
[Bash: npm test auth - 4500 tokens output]
Error: 测试失败，token 验证有问题
Claude: 修复验证逻辑
[Edit tool: src/auth.ts - 2000 tokens]
[Bash: npm test auth - 3000 tokens output]
All tests passed!
```

#### 压缩后 (2,500 tokens)

```
[Session Summary]
项目: 实现用户认证功能

关键决策:
- 选择 JWT 作为认证方案
- 使用 jsonwebtoken 库
- Token 过期时间设为 24 小时

已完成:
✓ 安装依赖 (jsonwebtoken, @types/jsonwebtoken)
✓ 实现 JWT 生成和验证逻辑 (src/auth.ts)
✓ 修复 token 验证问题（缺少 secret 校验）
✓ 所有测试通过

当前状态:
- 认证功能已完全实现
- 测试覆盖率 95%
- 准备集成到主应用

[Working Memory]
User: [最近的用户消息]
Claude: [最近的回复]
```

### Claude-Mem 插件增强

```
Claude-Mem 工作流:

┌─────────────────────────────────────┐
│  1. 观察阶段 (Observation)          │
│  ├─ 监控所有工具调用                │
│  ├─ 捕获关键决策点                  │
│  └─ 记录错误和修复                  │
└─────────────────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  2. 压缩阶段 (Compression)          │
│  ├─ AI 语义分析                     │
│  ├─ 提取核心要点                    │
│  └─ 生成结构化摘要                  │
└─────────────────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  3. 存储阶段 (Storage)              │
│  ├─ 保存到向量数据库                │
│  ├─ 建立语义索引                    │
│  └─ 跨会话共享                      │
└─────────────────────────────────────┘
             ↓
┌─────────────────────────────────────┐
│  4. 检索阶段 (Retrieval)            │
│  ├─ 语义搜索相关记忆                │
│  ├─ 自动注入到新会话                │
│  └─ 上下文增强                      │
└─────────────────────────────────────┘

示例记忆:

{
  "memory_id": "mem_auth_jwt",
  "type": "decision",
  "summary": "项目使用 JWT 认证，token 有效期 24h",
  "context": {
    "files": ["src/auth.ts"],
    "decisions": [
      "选择 JWT 而非 Session（因为需要 API 支持）",
      "使用 HS256 算法（对称加密）"
    ],
    "pitfalls": [
      "必须设置 secret，否则验证失败"
    ]
  },
  "relevance_score": 0.95,
  "created_at": "2026-02-08T10:30:00Z"
}
```

---

## 2.3 Token 预算管理

Claude Code 实现了**智能的 token 分配策略**。

### Token 预算分配

```
Claude Opus 4.5: 200,000 tokens 总预算

┌─────────────────────────────────────────────────────────┐
│                Token Budget Allocation                   │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  1. 系统保留 (System Reservation) - 20,000 tokens (10%) │
│  ┌────────────────────────────────────────────────┐     │
│  │  - 系统提示词 (~5,000)                         │     │
│  │  - 工具定义 (~10,000)                          │     │
│  │  - MCP 工具发现 (~3,000)                       │     │
│  │  - 保留缓冲 (~2,000)                           │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
│  2. 响应空间 (Response Space) - 16,000 tokens (8%)      │
│  ┌────────────────────────────────────────────────┐     │
│  │  - Claude 的回复 (~8,000)                      │     │
│  │  - 代码生成 (~4,000)                           │     │
│  │  - 工具调用参数 (~2,000)                       │     │
│  │  - 响应缓冲 (~2,000)                           │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
│  3. 活跃上下文 (Active Context) - 80,000 tokens (40%)   │
│  ┌────────────────────────────────────────────────┐     │
│  │  - 当前对话历史 (~30,000)                      │     │
│  │  - 项目上下文 (CLAUDE.md) (~10,000)            │     │
│  │  - 最近的工具调用结果 (~25,000)                │     │
│  │  - 任务状态 (~5,000)                           │     │
│  │  - 文件内容缓存 (~10,000)                      │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
│  4. 工作缓冲 (Working Buffer) - 60,000 tokens (30%)     │
│  ┌────────────────────────────────────────────────┐     │
│  │  - 扩展工具执行 (~30,000)                      │     │
│  │  - 临时文件读取 (~15,000)                      │     │
│  │  - 迭代空间 (~10,000)                          │     │
│  │  - 动态预留 (~5,000)                           │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
│  5. 压缩缓冲 (Compression Buffer) - 24,000 tokens (12%) │
│  ┌────────────────────────────────────────────────┐     │
│  │  - 触发压缩时的安全边界                        │     │
│  │  - 92% 阈值 = 184,000 tokens                   │     │
│  │  - 剩余 16,000 tokens 用于压缩操作             │     │
│  └────────────────────────────────────────────────┘     │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### Tool Search Token 优化

```
传统方法 vs Tool Search:

┌─────────────────────────────────────────┐
│  传统方法 (发送所有工具定义)            │
├─────────────────────────────────────────┤
│  系统提示: 5,000 tokens                 │
│  内置工具定义: 15,000 tokens            │
│  MCP 工具定义: 102,800 tokens  ⚠️       │
│  用户上下文: 78,200 tokens              │
│  ─────────────────────────────          │
│  总计: 200,000 tokens                   │
│                                         │
│  问题:                                  │
│  ❌ 61% 的空间被工具定义占用             │
│  ❌ 实际上下文空间严重不足               │
│  ❌ Claude 难以找到相关工具              │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  Tool Search 方法 (智能工具发现)        │
├─────────────────────────────────────────┤
│  系统提示: 5,000 tokens                 │
│  内置工具定义: 15,000 tokens            │
│  Tool Search 工具: 1,200 tokens         │
│  用户上下文: 160,000 tokens  ✅         │
│  按需加载的工具: 18,800 tokens          │
│  ─────────────────────────────          │
│  总计: 200,000 tokens                   │
│                                         │
│  优势:                                  │
│  ✅ 80% 的空间可用于实际上下文           │
│  ✅ 仅加载相关的 MCP 工具                │
│  ✅ 大幅提升响应质量                     │
│  ✅ 节省 ~84,000 tokens (42%)           │
└─────────────────────────────────────────┘

Tool Search 工作流程:

User: "我需要查询数据库中的用户数据"
    ↓
Claude: [调用 Tool Search]
    search_query: "database query user data"
    ↓
Tool Search: 返回相关工具
    - PostgreSQL Query Tool
    - MongoDB Query Tool
    - SQL Builder Tool
    (仅 ~3,000 tokens)
    ↓
Claude: 选择 PostgreSQL 工具
    [调用 PostgreSQL Query Tool]
```

### Token Counting API

```javascript
// 发送消息前检查 token 数量

import Anthropic from "@anthropic-ai/sdk";

const client = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// 计算消息的 token 数量
const tokenCount = await client.messages.countTokens({
  model: "claude-sonnet-4-5-20250929",
  messages: [
    {
      role: "user",
      content: "请分析这个大型代码文件..."
    }
  ],
  system: "你是一个代码审查专家",
  tools: [...toolDefinitions]
});

console.log(`总 tokens: ${tokenCount.input_tokens}`);

if (tokenCount.input_tokens > 180000) {
  // 触发预压缩
  console.log("警告: 接近上下文上限，建议压缩");
}
```

---

## 2.4 无限对话支持

### 实现机制

```
无限对话的三个支柱:

1. 智能压缩 (Compression)
   ├─ 92% 阈值自动触发
   ├─ 语义保留而非截断
   └─ 10:1 压缩比

2. 分层存储 (Tiered Storage)
   ├─ 热数据: Working Memory
   ├─ 温数据: Active Context
   └─ 冷数据: Persistent State

3. 按需加载 (Lazy Loading)
   ├─ 不预加载所有历史
   ├─ 语义搜索相关内容
   └─ 动态注入上下文
```

### 长期会话示例

```
会话生命周期:

Day 1: 项目初始化
├─ 对话轮次: 50
├─ Token 使用: 150k (75%)
└─ 操作: 创建项目结构、安装依赖

↓ (92% 阈值触发压缩)

压缩摘要 (15k tokens):
  "创建了 React + TypeScript 项目
   安装了 tailwind, react-router
   设置了 ESLint 和 Prettier 配置"

Day 2: 实现核心功能
├─ 对话轮次: 80
├─ Token 使用: 180k (90%)
└─ 操作: 实现认证、路由、API 集成

↓ (再次压缩)

累积摘要 (20k tokens):
  Day 1 摘要 + Day 2 新增:
  "实现了 JWT 认证和路由系统
   集成了 REST API
   添加了错误处理中间件"

Day 3-7: 持续开发
├─ 每天触发 1-2 次压缩
├─ 摘要逐渐累积
└─ 总是保持 < 92% 使用率

Week 2: 会话恢复
├─ claude --resume
├─ 加载持久化的摘要
├─ 完整的项目理解
└─ 无缝继续开发

结果:
  ✅ 支持数周的持续开发
  ✅ 不丢失关键上下文
  ✅ 始终有足够的工作空间
  ✅ 压缩比达到 10-15:1
```

### 跨会话连续性

```
场景: 在多个设备和平台间工作

Monday (办公室 - VS Code):
  ├─ 开始实现新功能
  ├─ 完成 60% 的工作
  └─ Session ID: sess_abc123

Tuesday (家中 - CLI):
  ├─ claude --resume sess_abc123
  ├─ 完整的上下文恢复
  ├─ Claude 记得所有之前的决策
  └─ 继续开发

Wednesday (咖啡店 - claude.ai Web):
  ├─ 打开 claude.ai
  ├─ Teleport sess_abc123
  ├─ 在浏览器中继续
  └─ 实时同步

Thursday (手机 - Claude App):
  ├─ 查看进度
  ├─ 做出设计决策
  └─ 添加到任务列表

Friday (办公室 - VS Code):
  ├─ 回到 VS Code
  ├─ 所有平台的工作完全同步
  └─ 完成功能并部署

关键能力:
  ✓ 跨设备无缝切换
  ✓ 完整的上下文保留
  ✓ 实时状态同步
  ✓ 支持多人协作
```

---

## 2.5 上下文管理命令

### 核心命令

```bash
# 1. 查看当前上下文使用情况
/context

输出示例:
┌─────────────────────────────────────┐
│ Context Usage                       │
├─────────────────────────────────────┤
│ Current: 142,500 / 200,000 (71%)    │
│                                     │
│ Breakdown:                          │
│ ├─ System: 20,000 (10%)             │
│ ├─ Conversation: 85,000 (42.5%)     │
│ ├─ Tool Results: 30,000 (15%)       │
│ └─ Files: 7,500 (3.75%)             │
│                                     │
│ Status: ✓ Healthy                   │
│ Next compaction at: 92% (184k)      │
└─────────────────────────────────────┘

# 2. 手动触发压缩
/compact

输出:
"压缩完成
 之前: 142,500 tokens
 之后: 58,300 tokens
 压缩比: 2.4:1
 释放: 84,200 tokens"

# 3. 清空对话历史 (保留任务)
/clear

警告提示:
"⚠️  这将清空当前对话历史
 任务列表和持久化状态会保留
 继续? [y/N]"

# 4. 查看任务列表 (跨会话)
/tasks

输出:
┌──────────────────────────────────────────┐
│ Task List                                │
├──────────────────────────────────────────┤
│ [1] ✓ Setup project structure           │
│ [2] ✓ Implement authentication           │
│ [3] ⏳ Add user dashboard (IN PROGRESS)  │
│ [4] ⏸  Implement API endpoints (BLOCKED) │
│ [5] ⏸  Write tests (BLOCKED BY: 3, 4)    │
└──────────────────────────────────────────┘

# 5. 查看会话历史
/history

输出:
Recent Sessions:
1. sess_xyz789 - "Feature: User Dashboard" (Current)
   Started: 2026-02-08 09:00
   Duration: 2h 15m

2. sess_abc123 - "Implement Auth System"
   Started: 2026-02-07 14:30
   Duration: 3h 45m
   Status: Completed

3. sess_def456 - "Project Setup"
   Started: 2026-02-07 10:00
   Duration: 1h 20m
   Status: Completed

# 6. 恢复之前的会话
claude --resume sess_abc123

# 7. 导出会话摘要
/export summary.md

生成文件:
summary.md
├─ 会话概览
├─ 关键决策
├─ 已完成的任务
├─ 代码更改摘要
└─ 下一步建议
```

### 高级上下文管理

```bash
# 项目级上下文注入
# 创建 CLAUDE.md 文件

cat > CLAUDE.md << 'EOF'
# 项目上下文

## 项目架构
- 前端: React + TypeScript + Tailwind
- 后端: Node.js + Express + PostgreSQL
- 认证: JWT (HS256)

## 关键决策
1. 使用 JWT 而非 Session（API 需求）
2. PostgreSQL 而非 MongoDB（关系数据）
3. Monorepo 结构（nx workspace）

## 代码规范
- 使用 ESLint + Prettier
- 提交前运行 lint 和 test
- 所有 API 必须有单元测试

## 常见陷阱
- JWT secret 必须从环境变量加载
- 数据库迁移需要手动运行
- 生产环境禁用 source maps

## 下一步
- [ ] 实现用户仪表板
- [ ] 添加 API 端点
- [ ] 编写 E2E 测试
EOF

# Claude 会自动加载这个文件作为持久化上下文
# 每次会话开始时注入，无需重复说明
```

---

## 2.6 实践技巧

### 最佳实践

```
1. 定期压缩 (Proactive Compaction)

   策略:
   ├─ 重大里程碑后手动 /compact
   │  例: 完成认证系统后
   │
   ├─ 每天开始工作前 /compact
   │  清理昨天的冗余信息
   │
   └─ 切换任务前 /compact
      为新任务腾出空间

2. 结构化的项目上下文 (CLAUDE.md)

   模板:

   # 项目上下文

   ## 技术栈
   [列出主要技术]

   ## 架构决策记录 (ADR)
   ### ADR-001: 选择认证方案
   决策: JWT
   原因: 需要 API 支持，无状态
   日期: 2026-02-01

   ## 代码规范
   [ESLint rules, 命名约定等]

   ## 常见问题和解决方案
   [FAQ 和 troubleshooting]

   ## 待办事项
   [高优先级任务列表]

3. 利用任务系统持久化 (Task Persistence)

   场景: 大型重构

   Session 1:
   ├─ 分析代码库 (Explore)
   ├─ 创建任务列表
   │  ├─ Task 1: 重构 auth 模块
   │  ├─ Task 2: 更新测试
   │  └─ Task 3: 更新文档
   └─ 退出会话

   Session 2:
   ├─ claude --resume
   ├─ 任务列表自动恢复
   └─ 从中断处继续

4. 智能文件引用 (Smart File References)

   避免:
   "请读取 auth.ts 并修改验证逻辑"
   → Claude 需要重新读取完整文件

   推荐:
   "在 auth.ts:45-67 的 verifyToken 函数中
    添加 token 过期检查"
   → Claude 可以精准定位，节省 tokens

5. 使用摘要而非详细日志

   避免:
   "运行 npm test 并告诉我所有输出"
   → 可能产生数千行输出

   推荐:
   "运行 npm test，如果失败告诉我错误摘要"
   → Claude 自动过滤相关信息
```

### 监控和优化

```bash
# 创建上下文监控脚本
cat > ~/.claude/scripts/context-monitor.sh << 'EOF'
#!/bin/bash

# 检查上下文使用率
check_context() {
    echo "=== Claude Code Context Monitor ==="

    # 假设 Claude 提供了 API
    USAGE=$(claude context --json | jq '.usage_percent')

    if [ "$USAGE" -gt 85 ]; then
        echo "⚠️  警告: 上下文使用率 $USAGE%"
        echo "建议执行: /compact"
    elif [ "$USAGE" -gt 70 ]; then
        echo "ℹ️  提示: 上下文使用率 $USAGE%"
        echo "接近压缩阈值"
    else
        echo "✓ 上下文使用率健康: $USAGE%"
    fi
}

check_context
EOF

chmod +x ~/.claude/scripts/context-monitor.sh

# 添加到 shell 启动脚本
echo 'alias claude-monitor="~/.claude/scripts/context-monitor.sh"' >> ~/.bashrc
```

### 性能对比

| 场景 | 不使用压缩 | 使用智能压缩 |
|------|-----------|-------------|
| **最大对话轮次** | ~50 轮 | 无限 |
| **会话时长** | 2-3 小时 | 数天/数周 |
| **上下文丢失** | 频繁 | 罕见 |
| **需要重复说明** | 经常 | 很少 |
| **响应质量** | 后期下降 | 持续高质量 |
| **跨会话连续性** | 不支持 | 完全支持 |

---

## 下一步

- 学习 [Subagent 系统](./03-subagent-system.md)，了解如何利用多代理并行处理
- 查看 [异步 Agent](./04-async-agents.md)，掌握后台任务管理
- 参考 [最佳实践](./08-best-practices.md)，优化上下文使用效率

---

**参考资源**:
- [Claude's Context Engineering Secrets](https://01.me/en/2025/12/context-engineering-from-claude/)
- [Claude Code 长期记忆管理](https://zhuanlan.zhihu.com/p/1935431442432778433)
- [上下文优化实践](https://mrzhangguoguo.github.io/posts/claude-code-memory-management-context-optimization-long-term-ai-programming-partner/)
