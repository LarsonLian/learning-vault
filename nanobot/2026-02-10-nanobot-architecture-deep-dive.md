# nanobot é¡¹ç›®æ¶æ„æ·±åº¦åˆ†æ

## æˆ˜ç•¥æ¦‚è¦

nanobot æ˜¯ä¸€ä¸ªè¶…è½»é‡çº§çš„ä¸ªäºº AI åŠ©æ‰‹æ¡†æ¶ï¼Œå…¶æ ¸å¿ƒç†å¿µæ˜¯"ç®€çº¦è€Œä¸ç®€å•"ã€‚ä»¥ä»… **~7500 è¡Œä»£ç **ï¼ˆæ ¸å¿ƒ Agent é€»è¾‘çº¦ 3500 è¡Œï¼‰å®ç°äº†å®Œæ•´çš„ AI Agent åŠŸèƒ½ï¼Œç›¸æ¯”åŒç±»é¡¹ç›® Clawdbotï¼ˆ43 ä¸‡è¡Œä»£ç ï¼‰å®ç°äº† **99% çš„ä»£ç é‡ç²¾ç®€**ã€‚è¯¥é¡¹ç›®é‡‡ç”¨æ¨¡å—åŒ–ã€äº‹ä»¶é©±åŠ¨çš„æ¶æ„è®¾è®¡ï¼Œæ”¯æŒå¤šæ¸ é“é€šä¿¡ã€å¤š LLM æä¾›å•†ã€å·¥å…·è°ƒç”¨ã€å­ Agent ç³»ç»Ÿã€å®šæ—¶ä»»åŠ¡ç­‰ä¼ä¸šçº§åŠŸèƒ½ã€‚

**æ ¸å¿ƒæ´å¯Ÿ**ï¼šnanobot é€šè¿‡ç²¾å¿ƒçš„æ¶æ„è®¾è®¡å’ŒæŠ½è±¡å±‚æ¬¡åˆ’åˆ†ï¼Œè¯æ˜äº†"å°è€Œç¾"çš„å·¥ç¨‹å®è·µå¯ä»¥åœ¨ä¿æŒä»£ç ç®€æ´æ€§çš„åŒæ—¶å®ç°å¤æ‚åŠŸèƒ½ã€‚

**ä¸»è¦å½±å“**ï¼šä¸º AI Agent å¼€å‘æä¾›äº†ä¸€ä¸ªæ¸…æ™°ã€å¯æ‰©å±•ã€æ˜“äºç†è§£çš„å‚è€ƒå®ç°ï¼Œç‰¹åˆ«é€‚åˆç ”ç©¶ã€å­¦ä¹ å’Œå¿«é€ŸåŸå‹å¼€å‘ã€‚

---

## å…³é”®é—®é¢˜

- nanobot å¦‚ä½•é€šè¿‡äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°æ¸ é“ä¸ Agent çš„è§£è€¦ï¼Ÿ
- å¤š LLM æä¾›å•†æ”¯æŒæ˜¯å¦‚ä½•é€šè¿‡æ³¨å†Œè¡¨æ¨¡å¼ç®€åŒ–é›†æˆçš„ï¼Ÿ
- å­ Agent ç³»ç»Ÿå¦‚ä½•å®ç°åå°ä»»åŠ¡çš„å¹¶å‘æ‰§è¡Œï¼Ÿ
- å·¥å…·ç³»ç»Ÿçš„è®¾è®¡å¦‚ä½•ä¿è¯å®‰å…¨æ€§å’Œå¯æ‰©å±•æ€§ï¼Ÿ
- ä¼šè¯ç®¡ç†å’Œè®°å¿†ç³»ç»Ÿå¦‚ä½•å®ç°ä¸Šä¸‹æ–‡æŒä¹…åŒ–ï¼Ÿ
- æ•´ä¸ªç³»ç»Ÿå¦‚ä½•å®ç°ç”Ÿäº§ç¯å¢ƒçš„éƒ¨ç½²å’Œè¿ç»´ï¼Ÿ

---

## ä¸€ã€æ•´ä½“æ¶æ„æ¦‚è§ˆ

### 1.1 æ¶æ„è®¾è®¡ç†å¿µ

nanobot é‡‡ç”¨**åˆ†å±‚æ¶æ„ + äº‹ä»¶é©±åŠ¨æ¨¡å¼**ï¼Œå°†ç³»ç»Ÿåˆ†è§£ä¸ºæ¸…æ™°çš„åŠŸèƒ½æ¨¡å—ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ç”¨æˆ·æ¥å£å±‚                            â”‚
â”‚  CLI Commands â”‚ Telegram â”‚ WhatsApp â”‚ Discord â”‚ Email ...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     é€šä¿¡æ¸ é“å±‚ (Channels)                    â”‚
â”‚              ChannelManager + BaseChannel æŠ½è±¡              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ¶ˆæ¯æ€»çº¿å±‚ (Message Bus)                  â”‚
â”‚              å¼‚æ­¥é˜Ÿåˆ— + å‘å¸ƒè®¢é˜…æ¨¡å¼                         â”‚
â”‚        Inbound Queue  â—„â”€â”€â”€â”€â”€â”€â–º  Outbound Queue             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ ¸å¿ƒ Agent å±‚                           â”‚
â”‚   AgentLoop â”‚ ContextBuilder â”‚ ToolRegistry â”‚ SubagentMgr  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LLM æä¾›å•†å±‚                             â”‚
â”‚         LiteLLM Provider + Registry-driven Routing          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ”¯æ’‘æœåŠ¡å±‚                              â”‚
â”‚  SessionManager â”‚ CronService â”‚ HeartbeatService â”‚ Memory  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒè®¾è®¡æ¨¡å¼

| è®¾è®¡æ¨¡å¼ | åº”ç”¨åœºæ™¯ | ä½ç½® |
|---------|---------|------|
| **å‘å¸ƒ-è®¢é˜…æ¨¡å¼** | æ¶ˆæ¯æ€»çº¿å®ç°æ¸ é“è§£è€¦ | `bus/queue.py` |
| **æ³¨å†Œè¡¨æ¨¡å¼** | å·¥å…·æ³¨å†Œã€LLM æä¾›å•†ç®¡ç† | `agent/tools/registry.py`, `providers/registry.py` |
| **ç­–ç•¥æ¨¡å¼** | LLM æä¾›å•†åˆ‡æ¢ | `providers/` |
| **å·¥å‚æ¨¡å¼** | æ¸ é“å®ä¾‹åŒ–ã€å·¥å…·åˆ›å»º | `channels/manager.py` |
| **æ¨¡æ¿æ–¹æ³•æ¨¡å¼** | BaseChannel æŠ½è±¡ç±» | `channels/base.py` |
| **å‘½ä»¤æ¨¡å¼** | å·¥å…·è°ƒç”¨æœºåˆ¶ | `agent/tools/base.py` |

---

## äºŒã€æ ¸å¿ƒæ¨¡å—æ·±åº¦å‰–æ

### 2.1 æ¶ˆæ¯æ€»çº¿ (Message Bus)

**æ–‡ä»¶ä½ç½®**: `nanobot/bus/queue.py`, `nanobot/bus/events.py`

**æ ¸å¿ƒèŒè´£**:
- è§£è€¦é€šä¿¡æ¸ é“ä¸ Agent æ ¸å¿ƒé€»è¾‘
- æä¾›å¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—æœºåˆ¶
- æ”¯æŒå¤šæ¸ é“å¹¶å‘å¤„ç†

**å®ç°ç»†èŠ‚**:

```python
class MessageBus:
    def __init__(self):
        self.inbound: asyncio.Queue[InboundMessage] = asyncio.Queue()
        self.outbound: asyncio.Queue[OutboundMessage] = asyncio.Queue()
        self._outbound_subscribers: dict[str, list[Callable]] = {}
```

**å…³é”®ç‰¹æ€§**:
1. **åŒå‘é˜Ÿåˆ—**: å…¥ç«™æ¶ˆæ¯ (Inbound) å’Œå‡ºç«™æ¶ˆæ¯ (Outbound) åˆ†ç¦»
2. **è®¢é˜…æœºåˆ¶**: æ¸ é“å¯ä»¥è®¢é˜…ç‰¹å®šæ¶ˆæ¯ç±»å‹
3. **å¼‚æ­¥æ´¾å‘**: æ”¯æŒé«˜å¹¶å‘åœºæ™¯
4. **è¶…æ—¶å¤„ç†**: 1 ç§’è¶…æ—¶é¿å…é˜»å¡

**æ•°æ®æµè½¬**:
```
User Message (Telegram)
  â†’ InboundMessage â†’ inbound.put()
  â†’ Agent.process_message()
  â†’ OutboundMessage â†’ outbound.put()
  â†’ ChannelManager.dispatch()
  â†’ Telegram.send()
  â†’ User receives reply
```

### 2.2 Agent æ ¸å¿ƒå¾ªç¯ (Agent Loop)

**æ–‡ä»¶ä½ç½®**: `nanobot/agent/loop.py`

**æ ¸å¿ƒç®—æ³•**:
```python
async def _process_message(self, msg: InboundMessage) -> OutboundMessage:
    # 1. è·å–æˆ–åˆ›å»ºä¼šè¯
    session = self.sessions.get_or_create(msg.session_key)

    # 2. æ„å»ºä¸Šä¸‹æ–‡ (ç³»ç»Ÿæç¤ºè¯ + å†å² + å½“å‰æ¶ˆæ¯)
    messages = self.context.build_messages(
        history=session.get_history(),
        current_message=msg.content,
        media=msg.media
    )

    # 3. Agent å¾ªç¯ (æœ€å¤š max_iterations æ¬¡)
    iteration = 0
    while iteration < self.max_iterations:
        # è°ƒç”¨ LLM
        response = await self.provider.chat(
            messages=messages,
            tools=self.tools.get_definitions()
        )

        # å¦‚æœæœ‰å·¥å…·è°ƒç”¨
        if response.has_tool_calls:
            # æ‰§è¡Œå·¥å…·
            for tool_call in response.tool_calls:
                result = await self.tools.execute(
                    tool_call.name,
                    tool_call.arguments
                )
                # å°†ç»“æœæ·»åŠ åˆ°æ¶ˆæ¯å†å²
                messages.append({
                    "role": "tool",
                    "content": result
                })
            iteration += 1
        else:
            # æ— å·¥å…·è°ƒç”¨ï¼Œè¿”å›æœ€ç»ˆå“åº”
            break

    # 4. ä¿å­˜ä¼šè¯
    session.add_message("user", msg.content)
    session.add_message("assistant", final_content)
    return OutboundMessage(...)
```

**å…³é”®è®¾è®¡å†³ç­–**:
- **æœ€å¤§è¿­ä»£æ¬¡æ•°**: é˜²æ­¢æ— é™å¾ªç¯ï¼ˆé»˜è®¤ 20 æ¬¡ï¼‰
- **å·¥å…·ç»“æœæ³¨å…¥**: å°†å·¥å…·æ‰§è¡Œç»“æœä½œä¸º `tool` è§’è‰²æ¶ˆæ¯è¿”å›ç»™ LLM
- **ä¼šè¯éš”ç¦»**: æ¯ä¸ª `channel:chat_id` ç‹¬ç«‹ä¼šè¯
- **é”™è¯¯ä¼˜é›…é™çº§**: å¼‚å¸¸æ—¶è¿”å›é”™è¯¯æ¶ˆæ¯è€Œéå´©æºƒ

### 2.3 ä¸Šä¸‹æ–‡æ„å»ºå™¨ (Context Builder)

**æ–‡ä»¶ä½ç½®**: `nanobot/agent/context.py`

**åŠŸèƒ½æ¨¡å—**:

1. **ç³»ç»Ÿæç¤ºè¯ç»„è£…**:
   ```python
   def build_system_prompt(self):
       parts = []
       # æ ¸å¿ƒèº«ä»½
       parts.append(self._get_identity())
       # å¯åŠ¨æ–‡ä»¶ (AGENTS.md, SOUL.md, USER.md, TOOLS.md)
       parts.append(self._load_bootstrap_files())
       # è®°å¿†ä¸Šä¸‹æ–‡
       parts.append(f"# Memory\n\n{self.memory.get_memory_context()}")
       # æŠ€èƒ½æ‘˜è¦ (æ¸è¿›å¼åŠ è½½)
       parts.append(self.skills.build_skills_summary())
       return "\n\n---\n\n".join(parts)
   ```

2. **æ¸è¿›å¼æŠ€èƒ½åŠ è½½**:
   - Always-loaded skills: å®Œæ•´å†…å®¹åŠ è½½åˆ°ä¸Šä¸‹æ–‡
   - Available skills: ä»…æ˜¾ç¤ºæ‘˜è¦ï¼Œéœ€è¦æ—¶ç”¨ `read_file` å·¥å…·åŠ è½½

3. **å¤šæ¨¡æ€æ”¯æŒ**:
   ```python
   def _build_user_content(self, text: str, media: list[str]):
       if not media:
           return text
       images = []
       for path in media:
           b64 = base64.b64encode(Path(path).read_bytes()).decode()
           images.append({
               "type": "image_url",
               "image_url": {"url": f"data:{mime};base64,{b64}"}
           })
       return images + [{"type": "text", "text": text}]
   ```

### 2.4 å·¥å…·ç³»ç»Ÿ (Tool System)

**æ–‡ä»¶ä½ç½®**: `nanobot/agent/tools/`

**æ¶æ„è®¾è®¡**:

```python
# åŸºç±»å®šä¹‰
class Tool(ABC):
    name: str
    description: str
    parameters: dict

    @abstractmethod
    async def execute(self, **kwargs) -> str:
        pass

    def to_schema(self) -> dict:
        """è½¬æ¢ä¸º OpenAI Function Calling æ ¼å¼"""
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": self.parameters
            }
        }
```

**å†…ç½®å·¥å…·æ¸…å•**:

| å·¥å…·åç§° | åŠŸèƒ½ | å®‰å…¨æœºåˆ¶ |
|---------|------|---------|
| `read_file` | æ–‡ä»¶è¯»å– | `allowed_dir` é™åˆ¶ |
| `write_file` | æ–‡ä»¶å†™å…¥ | å·¥ä½œåŒºæ²™ç®± |
| `edit_file` | æ–‡ä»¶ç¼–è¾‘ | è·¯å¾„éªŒè¯ |
| `list_dir` | ç›®å½•åˆ—è¡¨ | ç›®å½•éå†ä¿æŠ¤ |
| `exec` | Shell å‘½ä»¤ | è¶…æ—¶ + æ²™ç®± |
| `web_search` | ç½‘é¡µæœç´¢ | Brave API |
| `web_fetch` | ç½‘é¡µæŠ“å– | å†…å®¹æ¸…æ´— |
| `message` | æ¶ˆæ¯å‘é€ | æ¸ é“è·¯ç”± |
| `spawn` | å­ Agent ç”Ÿæˆ | å¹¶å‘é™åˆ¶ |
| `cron` | å®šæ—¶ä»»åŠ¡ | æƒé™æ£€æŸ¥ |

**å®‰å…¨æœºåˆ¶**:

```python
class ExecTool(Tool):
    def __init__(
        self,
        working_dir: str,
        timeout: int = 60,
        restrict_to_workspace: bool = False
    ):
        self.restrict_to_workspace = restrict_to_workspace
        self.workspace_path = Path(working_dir).resolve()

    async def execute(self, command: str) -> str:
        # 1. å‘½ä»¤ç™½åå•æ£€æŸ¥
        dangerous = ["rm -rf /", "dd if=/dev/zero"]
        if any(d in command for d in dangerous):
            return "Error: Dangerous command blocked"

        # 2. æ²™ç®±é™åˆ¶
        if self.restrict_to_workspace:
            # é™åˆ¶åœ¨å·¥ä½œåŒºå†…æ‰§è¡Œ
            ...

        # 3. è¶…æ—¶ä¿æŠ¤
        proc = await asyncio.create_subprocess_shell(
            command,
            stdout=PIPE,
            stderr=PIPE
        )
        try:
            await asyncio.wait_for(proc.communicate(), timeout=self.timeout)
        except asyncio.TimeoutError:
            proc.kill()
            return "Error: Command timed out"
```

### 2.5 å­ Agent ç³»ç»Ÿ (Subagent Manager)

**æ–‡ä»¶ä½ç½®**: `nanobot/agent/subagent.py`

**è®¾è®¡ç›®æ ‡**:
- åå°ä»»åŠ¡å¹¶å‘æ‰§è¡Œ
- ä¸» Agent ä¸é˜»å¡
- ä»»åŠ¡å®Œæˆåä¸»åŠ¨é€šçŸ¥

**å·¥ä½œæµç¨‹**:

```python
# 1. ä¸» Agent è°ƒç”¨ spawn å·¥å…·
spawn_tool.execute(task="åˆ†ææ—¥å¿—æ–‡ä»¶", label="æ—¥å¿—åˆ†æ")

# 2. SubagentManager åˆ›å»ºåå°ä»»åŠ¡
async def spawn(self, task, label, origin_channel, origin_chat_id):
    task_id = str(uuid.uuid4())[:8]
    bg_task = asyncio.create_task(self._run_subagent(...))
    self._running_tasks[task_id] = bg_task
    return f"Subagent [{label}] started (id: {task_id})"

# 3. å­ Agent ç‹¬ç«‹æ‰§è¡Œï¼ˆæ—  message/spawn å·¥å…·ï¼‰
async def _run_subagent(self, task_id, task, label, origin):
    tools = ToolRegistry()  # ç²¾ç®€å·¥å…·é›†
    tools.register(ReadFileTool())
    tools.register(WebSearchTool())
    # ... æ‰§è¡Œä»»åŠ¡

    # 4. å®Œæˆåé€šè¿‡ç³»ç»Ÿæ¶ˆæ¯é€šçŸ¥ä¸» Agent
    await self._announce_result(task_id, label, result, origin)

# 5. ä¸» Agent æ¥æ”¶ç³»ç»Ÿæ¶ˆæ¯å¹¶å“åº”ç”¨æˆ·
async def _process_system_message(self, msg):
    # è§£æç»“æœå¹¶è‡ªç„¶è¯­è¨€å›å¤ç”¨æˆ·
    response = await self.provider.chat(
        messages=[{"role": "user", "content": msg.content}]
    )
```

**å…³é”®ç‰¹æ€§**:
- **éš”ç¦»ä¸Šä¸‹æ–‡**: å­ Agent æœ‰ç‹¬ç«‹ç³»ç»Ÿæç¤ºè¯
- **ç²¾ç®€å·¥å…·é›†**: ç§»é™¤ `message` å’Œ `spawn` é¿å…é€’å½’
- **ç»“æœå›è°ƒ**: é€šè¿‡æ¶ˆæ¯æ€»çº¿å¼‚æ­¥é€šçŸ¥
- **ä»»åŠ¡è¿½è¸ª**: `_running_tasks` å­—å…¸ç®¡ç†ç”Ÿå‘½å‘¨æœŸ

### 2.6 LLM æä¾›å•†ç³»ç»Ÿ

**æ–‡ä»¶ä½ç½®**: `nanobot/providers/`

**æ³¨å†Œè¡¨é©±åŠ¨è®¾è®¡**:

```python
@dataclass(frozen=True)
class ProviderSpec:
    name: str                    # é…ç½®å­—æ®µå "openrouter"
    keywords: tuple[str, ...]    # æ¨¡å‹åå…³é”®è¯åŒ¹é…
    env_key: str                 # ç¯å¢ƒå˜é‡ "OPENROUTER_API_KEY"
    litellm_prefix: str          # æ¨¡å‹å‰ç¼€ "openrouter/"
    is_gateway: bool             # æ˜¯å¦ä¸ºç½‘å…³æœåŠ¡
    model_overrides: tuple       # ç‰¹å®šæ¨¡å‹å‚æ•°è¦†ç›–

PROVIDERS = (
    ProviderSpec(
        name="openrouter",
        keywords=("openrouter",),
        env_key="OPENROUTER_API_KEY",
        litellm_prefix="openrouter",
        is_gateway=True,
        detect_by_key_prefix="sk-or-"
    ),
    # ... æ›´å¤šæä¾›å•†
)
```

**æ·»åŠ æ–°æä¾›å•†ä»…éœ€ 2 æ­¥**:
1. åœ¨ `registry.py` æ·»åŠ  `ProviderSpec`
2. åœ¨ `config/schema.py` æ·»åŠ é…ç½®å­—æ®µ

**è‡ªåŠ¨åŒ–åŠŸèƒ½**:
- ç¯å¢ƒå˜é‡è®¾ç½®
- æ¨¡å‹åå‰ç¼€è¡¥å…¨
- ç½‘å…³æ£€æµ‹
- å‚æ•°è¦†ç›–ï¼ˆå¦‚ Kimi K2.5 å¼ºåˆ¶ `temperature=1.0`ï¼‰

### 2.7 ä¼šè¯ç®¡ç† (Session Manager)

**æ–‡ä»¶ä½ç½®**: `nanobot/session/manager.py`

**å­˜å‚¨æ ¼å¼**: JSONL (æ¯è¡Œä¸€ä¸ª JSON å¯¹è±¡)

```jsonl
{"_type":"metadata","created_at":"2026-02-10T10:00:00","updated_at":"2026-02-10T10:05:00"}
{"role":"user","content":"ä½ å¥½","timestamp":"2026-02-10T10:00:00"}
{"role":"assistant","content":"ä½ å¥½ï¼æœ‰ä»€ä¹ˆå¯ä»¥å¸®ä½ çš„å—ï¼Ÿ","timestamp":"2026-02-10T10:00:05"}
```

**å…³é”®ç‰¹æ€§**:
1. **æŒä¹…åŒ–**: æ–‡ä»¶å­˜å‚¨åœ¨ `~/.nanobot/sessions/`
2. **æ‡’åŠ è½½**: é¦–æ¬¡è®¿é—®æ—¶åŠ è½½ï¼Œä½¿ç”¨å†…å­˜ç¼“å­˜
3. **ä¸Šä¸‹æ–‡çª—å£**: `get_history(max_messages=50)` é™åˆ¶ä¸Šä¸‹æ–‡é•¿åº¦
4. **çº¿ç¨‹å®‰å…¨**: å•ä¼šè¯å•çº¿ç¨‹è®¿é—®ï¼ˆé€šè¿‡ asyncio ä¿è¯ï¼‰

### 2.8 æ¸ é“ç³»ç»Ÿ (Channels)

**æ–‡ä»¶ä½ç½®**: `nanobot/channels/`

**æ”¯æŒçš„æ¸ é“**:

| æ¸ é“ | å®ç°æ–¹å¼ | å…³é”®ä¾èµ– |
|-----|---------|---------|
| Telegram | Long Polling | `python-telegram-bot` |
| Discord | WebSocket Gateway | åŸç”Ÿ WebSocket |
| WhatsApp | QR ç™»å½• + Node.js Bridge | `whatsapp-web.js` |
| Feishu | WebSocket é•¿è¿æ¥ | `lark-oapi` |
| DingTalk | Stream Mode | `dingtalk-stream` |
| Slack | Socket Mode | `slack-sdk` |
| QQ | botpy SDK | `qq-botpy` |
| Email | IMAP/SMTP è½®è¯¢ | åŸç”Ÿ `imaplib`, `smtplib` |

**BaseChannel æŠ½è±¡**:

```python
class BaseChannel(ABC):
    @abstractmethod
    async def start(self) -> None:
        """å¯åŠ¨æ¸ é“ç›‘å¬"""
        pass

    @abstractmethod
    async def stop(self) -> None:
        """åœæ­¢æ¸ é“"""
        pass

    @abstractmethod
    async def send(self, msg: OutboundMessage) -> None:
        """å‘é€æ¶ˆæ¯åˆ°æ¸ é“"""
        pass

    def _should_handle(self, sender_id: str) -> bool:
        """ç™½åå•æ£€æŸ¥"""
        if not self.config.allow_from:
            return True  # ç©ºç™½åå• = å…è®¸æ‰€æœ‰
        return sender_id in self.config.allow_from
```

**Telegram æ¸ é“å®ç°ç¤ºä¾‹**:

```python
class TelegramChannel(BaseChannel):
    async def start(self):
        self.app = Application.builder().token(self.config.token).build()
        self.app.add_handler(MessageHandler(filters.TEXT, self._on_message))
        self.app.add_handler(MessageHandler(filters.VOICE, self._on_voice))
        await self.app.run_polling()

    async def _on_message(self, update, context):
        if not self._should_handle(str(update.effective_user.id)):
            return

        msg = InboundMessage(
            channel="telegram",
            sender_id=str(update.effective_user.id),
            chat_id=str(update.effective_chat.id),
            content=update.message.text
        )
        await self.bus.publish_inbound(msg)
```

---

## ä¸‰ã€æŠ€æœ¯æ ˆè¯¦è§£

### 3.1 æ ¸å¿ƒä¾èµ–

| ä¾èµ– | ç‰ˆæœ¬è¦æ±‚ | ç”¨é€” |
|-----|---------|------|
| **Python** | â‰¥3.11 | ç±»å‹æç¤ºã€async æ”¹è¿› |
| **litellm** | â‰¥1.0.0 | å¤š LLM æä¾›å•†ç»Ÿä¸€æ¥å£ |
| **pydantic** | â‰¥2.0.0 | é…ç½®éªŒè¯ã€ç±»å‹å®‰å…¨ |
| **typer** | â‰¥0.9.0 | CLI æ„å»º |
| **loguru** | â‰¥0.7.0 | æ—¥å¿—ç®¡ç† |
| **rich** | â‰¥13.0.0 | ç»ˆç«¯ç¾åŒ– |

### 3.2 å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹

**æ ¸å¿ƒæœºåˆ¶**: `asyncio` + åç¨‹

```python
# å…¸å‹çš„å¼‚æ­¥æ¨¡å¼
async def run():
    await asyncio.gather(
        agent.run(),              # Agent ä¸»å¾ªç¯
        channels.start_all(),     # æ‰€æœ‰æ¸ é“ç›‘å¬
        cron.start(),             # å®šæ—¶ä»»åŠ¡æœåŠ¡
        heartbeat.start()         # å¿ƒè·³æœåŠ¡
    )

asyncio.run(run())
```

**å¹¶å‘å¤„ç†**:
- **æ¶ˆæ¯æ€»çº¿**: é˜Ÿåˆ—è§£è€¦ï¼Œé¿å…é˜»å¡
- **å­ Agent**: `asyncio.create_task` åå°æ‰§è¡Œ
- **å¤šæ¸ é“**: æ¯ä¸ªæ¸ é“ç‹¬ç«‹åç¨‹

### 3.3 æ•°æ®æŒä¹…åŒ–

| æ•°æ®ç±»å‹ | å­˜å‚¨ä½ç½® | æ ¼å¼ |
|---------|---------|------|
| é…ç½® | `~/.nanobot/config.json` | JSON |
| ä¼šè¯å†å² | `~/.nanobot/sessions/*.jsonl` | JSONL |
| å®šæ—¶ä»»åŠ¡ | `~/.nanobot/data/cron/jobs.json` | JSON |
| è®°å¿† | `~/.nanobot/workspace/memory/MEMORY.md` | Markdown |
| æ—¥å¿— | `~/.nanobot/workspace/memory/YYYY-MM-DD.md` | Markdown |

---

## å››ã€éƒ¨ç½²ä¸è¿ç»´

### 4.1 éƒ¨ç½²æ–¹å¼

#### æ–¹å¼ 1: PyPI å®‰è£…ï¼ˆç”Ÿäº§æ¨èï¼‰

```bash
# ä½¿ç”¨ uvï¼ˆå¿«é€Ÿï¼‰
uv tool install nanobot-ai

# æˆ–ä½¿ç”¨ pip
pip install nanobot-ai

# åˆå§‹åŒ–
nanobot onboard

# ç¼–è¾‘é…ç½®
vim ~/.nanobot/config.json

# å¯åŠ¨ç½‘å…³
nanobot gateway
```

#### æ–¹å¼ 2: Docker å®¹å™¨åŒ–

```dockerfile
FROM ghcr.io/astral-sh/uv:python3.12-bookworm-slim

# å®‰è£… Node.js (WhatsApp Bridge)
RUN apt-get update && apt-get install -y nodejs npm

# å®‰è£… nanobot
COPY nanobot/ bridge/ pyproject.toml ./
RUN uv pip install --system .

# æ„å»º WhatsApp Bridge
WORKDIR /app/bridge
RUN npm install && npm run build

EXPOSE 18790
ENTRYPOINT ["nanobot"]
CMD ["gateway"]
```

**Docker è¿è¡Œ**:
```bash
# æ„å»ºé•œåƒ
docker build -t nanobot .

# åˆå§‹åŒ–é…ç½®
docker run -v ~/.nanobot:/root/.nanobot nanobot onboard

# å¯åŠ¨ç½‘å…³
docker run -d \
  -v ~/.nanobot:/root/.nanobot \
  -p 18790:18790 \
  nanobot gateway
```

#### æ–¹å¼ 3: æºç å¼€å‘æ¨¡å¼

```bash
git clone https://github.com/HKUDS/nanobot.git
cd nanobot
pip install -e .
nanobot onboard
nanobot gateway
```

### 4.2 é…ç½®ç®¡ç†

**é…ç½®æ–‡ä»¶ç»“æ„**: `~/.nanobot/config.json`

```json
{
  "providers": {
    "openrouter": {
      "apiKey": "sk-or-v1-...",
      "apiBase": null,
      "extraHeaders": {}
    },
    "anthropic": {"apiKey": ""},
    "groq": {"apiKey": ""}
  },
  "agents": {
    "defaults": {
      "workspace": "~/.nanobot/workspace",
      "model": "anthropic/claude-opus-4-5",
      "maxTokens": 8192,
      "temperature": 0.7,
      "maxToolIterations": 20
    }
  },
  "channels": {
    "telegram": {
      "enabled": true,
      "token": "YOUR_BOT_TOKEN",
      "allowFrom": ["123456789"],
      "proxy": null
    },
    "email": {
      "enabled": false,
      "consentGranted": false,
      "imapHost": "imap.gmail.com",
      "smtpHost": "smtp.gmail.com"
    }
  },
  "tools": {
    "restrictToWorkspace": false,
    "web": {
      "search": {"apiKey": ""}
    },
    "exec": {
      "timeout": 60
    }
  }
}
```

**ç¯å¢ƒå˜é‡è¦†ç›–**:
```bash
export NANOBOT_PROVIDERS__OPENROUTER__API_KEY="sk-or-..."
export NANOBOT_TOOLS__RESTRICT_TO_WORKSPACE=true
```

### 4.3 ç›‘æ§ä¸æ—¥å¿—

**æ—¥å¿—ç³»ç»Ÿ**: åŸºäº `loguru`

```python
from loguru import logger

# é»˜è®¤æ—¥å¿—çº§åˆ«: INFO
logger.info("Agent loop started")
logger.error(f"Error processing message: {e}")

# CLI å¼€å¯è¯¦ç»†æ—¥å¿—
nanobot agent --logs
```

**è¿è¡ŒçŠ¶æ€æ£€æŸ¥**:
```bash
# æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€
nanobot status

# è¾“å‡ºç¤ºä¾‹:
# Config: ~/.nanobot/config.json âœ“
# Workspace: ~/.nanobot/workspace âœ“
# Model: anthropic/claude-opus-4-5
# OpenRouter: âœ“
# Groq: âœ“
```

**å®šæ—¶ä»»åŠ¡ç›‘æ§**:
```bash
nanobot cron list

# è¾“å‡º:
# ID       Name     Schedule      Status    Next Run
# abc123   daily    0 9 * * *     enabled   2026-02-11 09:00
```

### 4.4 å®‰å…¨åŠ å›º

**ç”Ÿäº§ç¯å¢ƒé…ç½®**:

```json
{
  "tools": {
    "restrictToWorkspace": true  // å¼ºåˆ¶å·¥å…·æ²™ç®±
  },
  "channels": {
    "telegram": {
      "allowFrom": ["123456789"]  // ç”¨æˆ·ç™½åå•
    }
  }
}
```

**æœ€ä½³å®è·µ**:
1. **API å¯†é’¥ç®¡ç†**: ä½¿ç”¨ç¯å¢ƒå˜é‡æˆ–å¯†é’¥ç®¡ç†æœåŠ¡
2. **æ¸ é“ç™½åå•**: ç”Ÿäº§ç¯å¢ƒå¿…é¡»é…ç½® `allowFrom`
3. **å·¥å…·æ²™ç®±**: `restrictToWorkspace=true` é˜²æ­¢è·¯å¾„éå†
4. **å‘½ä»¤è¶…æ—¶**: `exec.timeout` é˜²æ­¢é•¿æ—¶é—´é˜»å¡
5. **é‚®ä»¶éšç§**: `email.consentGranted` æ˜¾å¼æˆæƒ

### 4.5 æ°´å¹³æ‰©å±•

**å•å®ä¾‹æ€§èƒ½**:
- **å¹¶å‘å¤„ç†**: é€šè¿‡ asyncio æ”¯æŒæ•°ç™¾å¹¶å‘ä¼šè¯
- **ç“¶é¢ˆ**: LLM API è°ƒç”¨å»¶è¿Ÿï¼ˆé€šå¸¸ 1-5 ç§’ï¼‰

**å¤šå®ä¾‹éƒ¨ç½²**:
```bash
# å®ä¾‹ 1: Telegram + Discord
docker run -e CHANNELS=telegram,discord nanobot gateway

# å®ä¾‹ 2: WhatsApp + Email
docker run -e CHANNELS=whatsapp,email nanobot gateway
```

**è´Ÿè½½å‡è¡¡è€ƒè™‘**:
- **ä¼šè¯äº²å’Œæ€§**: åŒä¸€ç”¨æˆ·è¯·æ±‚éœ€è·¯ç”±åˆ°åŒä¸€å®ä¾‹ï¼ˆé€šè¿‡ `session_key`ï¼‰
- **å…±äº«å­˜å‚¨**: ä¼šè¯æ–‡ä»¶å­˜å‚¨åœ¨å…±äº«å·ï¼ˆNFS/S3ï¼‰

---

## äº”ã€è®¾è®¡æ¨¡å¼ä¸æœ€ä½³å®è·µ

### 5.1 ä»£ç ç»„ç»‡åŸåˆ™

**å•ä¸€èŒè´£**:
- `loop.py`: ä»…è´Ÿè´£ Agent ä¸»å¾ªç¯
- `context.py`: ä»…è´Ÿè´£æç¤ºè¯æ„å»º
- `tools/`: æ¯ä¸ªå·¥å…·ä¸€ä¸ªæ–‡ä»¶

**ä¾èµ–æ³¨å…¥**:
```python
class AgentLoop:
    def __init__(
        self,
        bus: MessageBus,           # æ³¨å…¥æ¶ˆæ¯æ€»çº¿
        provider: LLMProvider,     # æ³¨å…¥ LLM æä¾›å•†
        workspace: Path,           # æ³¨å…¥å·¥ä½œåŒºè·¯å¾„
        ...
    ):
        self.bus = bus
        self.provider = provider
```

**æ¥å£æŠ½è±¡**:
```python
# å®šä¹‰åè®®
class LLMProvider(ABC):
    @abstractmethod
    async def chat(self, messages, tools, model) -> LLMResponse:
        pass

# å¤šå®ç°
class LiteLLMProvider(LLMProvider): ...
class LocalLLMProvider(LLMProvider): ...
```

### 5.2 é”™è¯¯å¤„ç†ç­–ç•¥

**åˆ†å±‚é”™è¯¯å¤„ç†**:

```python
# 1. å·¥å…·å±‚: æ•è·å¹¶è¿”å›é”™è¯¯å­—ç¬¦ä¸²
async def execute(self, command: str) -> str:
    try:
        result = await run_command(command)
        return result
    except Exception as e:
        return f"Error: {str(e)}"  # è¿”å›ç»™ LLM

# 2. Agent å±‚: æ•è·å¹¶å‘é€é”™è¯¯å“åº”
try:
    response = await self._process_message(msg)
except Exception as e:
    await self.bus.publish_outbound(OutboundMessage(
        content=f"Sorry, I encountered an error: {str(e)}"
    ))

# 3. æ¸ é“å±‚: æ•è·å¹¶è®°å½•æ—¥å¿—
try:
    await channel.start()
except Exception as e:
    logger.error(f"Failed to start channel: {e}")
```

### 5.3 æ€§èƒ½ä¼˜åŒ–æŠ€å·§

**1. ä¸Šä¸‹æ–‡å‹ç¼©**:
```python
# åªä¿ç•™æœ€è¿‘ 50 æ¡æ¶ˆæ¯
history = session.get_history(max_messages=50)

# æ¸è¿›å¼æŠ€èƒ½åŠ è½½
# Always-loaded: å®Œæ•´å†…å®¹
# Available: ä»…æ‘˜è¦
```

**2. å¹¶å‘å·¥å…·è°ƒç”¨**:
```python
# å¹¶è¡Œæ‰§è¡Œå¤šä¸ªç‹¬ç«‹å·¥å…·
if len(tool_calls) > 1:
    results = await asyncio.gather(
        *[self.tools.execute(tc.name, tc.args) for tc in tool_calls]
    )
```

**3. ç¼“å­˜ç­–ç•¥**:
```python
class SessionManager:
    def __init__(self):
        self._cache: dict[str, Session] = {}  # å†…å­˜ç¼“å­˜

    def get_or_create(self, key: str):
        if key in self._cache:
            return self._cache[key]
        session = self._load(key)
        self._cache[key] = session
        return session
```

### 5.4 å¯æ‰©å±•æ€§è®¾è®¡

**æ·»åŠ æ–°å·¥å…·**:

```python
# 1. ç»§æ‰¿ Tool åŸºç±»
class CustomTool(Tool):
    name = "custom_action"
    description = "æ‰§è¡Œè‡ªå®šä¹‰æ“ä½œ"
    parameters = {
        "type": "object",
        "properties": {
            "param1": {"type": "string"}
        },
        "required": ["param1"]
    }

    async def execute(self, param1: str) -> str:
        # å®ç°é€»è¾‘
        return f"æ‰§è¡Œç»“æœ: {param1}"

# 2. æ³¨å†Œåˆ° Agent
agent.tools.register(CustomTool())
```

**æ·»åŠ æ–°æ¸ é“**:

```python
# 1. ç»§æ‰¿ BaseChannel
class MyChannel(BaseChannel):
    async def start(self):
        # å¯åŠ¨ç›‘å¬é€»è¾‘
        pass

    async def send(self, msg: OutboundMessage):
        # å‘é€æ¶ˆæ¯é€»è¾‘
        pass

# 2. åœ¨ ChannelManager æ³¨å†Œ
if config.channels.mychannel.enabled:
    self.channels["mychannel"] = MyChannel(config, bus)
```

---

## å…­ã€å…³é”®è®¾è®¡æƒè¡¡

### 6.1 æ€§èƒ½ vs ç®€æ´æ€§

**æƒè¡¡**: é€‰æ‹©ç®€æ´æ€§
- **æ— ç¼“å­˜å±‚**: ç›´æ¥è°ƒç”¨ LLMï¼Œä¸ç¼“å­˜å“åº”
- **JSONL å­˜å‚¨**: è€Œéæ•°æ®åº“ï¼Œä¾¿äºè°ƒè¯•
- **åŒæ­¥å·¥å…·æ‰§è¡Œ**: å·¥å…·æŒ‰åºæ‰§è¡Œï¼Œè€Œéå¹¶è¡Œ

**åŸå› **:
- 99% åœºæ™¯ä¸‹æ€§èƒ½è¶³å¤Ÿ
- å‡å°‘ 50% ä»£ç å¤æ‚åº¦
- æ˜“äºç†è§£å’Œç»´æŠ¤

### 6.2 çµæ´»æ€§ vs çº¦æŸæ€§

**æƒè¡¡**: ä¸­åº¸ä¹‹é“
- **å·¥å…·ç³»ç»Ÿ**: çµæ´»æ³¨å†Œï¼Œä½†å¼ºåˆ¶å‚æ•°éªŒè¯
- **LLM æä¾›å•†**: æ”¯æŒå¤šå®¶ï¼Œä½†ç»Ÿä¸€åˆ° LiteLLM æ¥å£
- **é…ç½®ç®¡ç†**: JSON æ–‡ä»¶ï¼ˆç®€å•ï¼‰ï¼Œæ”¯æŒç¯å¢ƒå˜é‡è¦†ç›–ï¼ˆçµæ´»ï¼‰

### 6.3 å®‰å…¨æ€§ vs åŠŸèƒ½æ€§

**æƒè¡¡**: å¯é…ç½®çš„å®‰å…¨ç­‰çº§
- **é»˜è®¤**: å¼€æ”¾æ¨¡å¼ï¼ˆ`restrictToWorkspace=false`ï¼‰ä¾¿äºå¼€å‘
- **ç”Ÿäº§**: æ²™ç®±æ¨¡å¼ï¼ˆ`restrictToWorkspace=true`ï¼‰å¼ºåˆ¶éš”ç¦»
- **å·¥å…·ç™½åå•**: å±é™©å‘½ä»¤ç¡¬ç¼–ç æ‹¦æˆª

---

## ä¸ƒã€åº”ç”¨åœºæ™¯ä¸é™åˆ¶

### 7.1 é€‚ç”¨åœºæ™¯

âœ… **ä¸ªäºº AI åŠ©æ‰‹**: æ—¥ç¨‹ç®¡ç†ã€é‚®ä»¶å¤„ç†ã€çŸ¥è¯†ç®¡ç†
âœ… **ç ”å‘å·¥å…·**: ä»£ç å®¡æŸ¥ã€æ—¥å¿—åˆ†æã€æ–‡æ¡£ç”Ÿæˆ
âœ… **ç ”ç©¶åŸå‹**: AI Agent ç®—æ³•éªŒè¯ã€å·¥å…·è°ƒç”¨ç ”ç©¶
âœ… **æ•™è‚²ç”¨é€”**: å­¦ä¹  Agent æ¶æ„ã€å¼‚æ­¥ç¼–ç¨‹

### 7.2 ä¸é€‚ç”¨åœºæ™¯

âŒ **é«˜å¹¶å‘åœºæ™¯**: å•å®ä¾‹ QPS < 100ï¼ˆå—é™äº LLM å»¶è¿Ÿï¼‰
âŒ **ä¼ä¸šçº§å¤šç§Ÿæˆ·**: ç¼ºå°‘ç§Ÿæˆ·éš”ç¦»ã€æƒé™ç³»ç»Ÿ
âŒ **å®æ—¶å¯¹è¯**: æ— æµå¼å“åº”ï¼ˆstreamï¼‰æ”¯æŒ
âŒ **å¤æ‚å·¥ä½œæµ**: ç¼ºå°‘å·¥ä½œæµå¼•æ“ã€çŠ¶æ€æœº

### 7.3 å·²çŸ¥é™åˆ¶

1. **ä¸Šä¸‹æ–‡çª—å£**: æœ€å¤§ 50 æ¡å†å²æ¶ˆæ¯ï¼ˆå— LLM é™åˆ¶ï¼‰
2. **å·¥å…·æ‰§è¡Œè¶…æ—¶**: é»˜è®¤ 60 ç§’ï¼ˆé•¿ä»»åŠ¡éœ€ä½¿ç”¨å­ Agentï¼‰
3. **å¹¶å‘å­ Agent**: æ— é™åˆ¶ï¼ˆéœ€æ‰‹åŠ¨æ§åˆ¶ï¼‰
4. **æ–‡ä»¶å¤§å°**: å·¥å…·è¯»å–æ–‡ä»¶æ— å¤§å°é™åˆ¶ï¼ˆå¯èƒ½ OOMï¼‰

---

## å…«ã€å…³é”®è¦ç‚¹æ€»ç»“

### æ ¸å¿ƒæ´å¯Ÿ

1. **æç®€æ¶æ„**: 7500 è¡Œä»£ç å®ç°å®Œæ•´ Agent åŠŸèƒ½
2. **äº‹ä»¶é©±åŠ¨**: æ¶ˆæ¯æ€»çº¿è§£è€¦æ¸ é“ä¸ Agent
3. **æ³¨å†Œè¡¨æ¨¡å¼**: å·¥å…·å’Œ LLM æä¾›å•†å³æ’å³ç”¨
4. **å¼‚æ­¥ä¼˜å…ˆ**: asyncio é©±åŠ¨é«˜å¹¶å‘
5. **æ¸è¿›å¼åŠ è½½**: ä¸Šä¸‹æ–‡æŒ‰éœ€åŠ è½½ï¼Œé¿å…è†¨èƒ€

### æ¶æ„ä¼˜åŠ¿

- âœ… **ä»£ç å¯è¯»æ€§é«˜**: æ–°æ‰‹ 1 å¤©ç†è§£æ ¸å¿ƒé€»è¾‘
- âœ… **æ‰©å±•æ€§å¼º**: æ–°å¢å·¥å…·/æ¸ é“ä»…éœ€ 2 æ­¥
- âœ… **æµ‹è¯•å‹å¥½**: æ¨¡å—è§£è€¦ï¼Œå•å…ƒæµ‹è¯•ç®€å•
- âœ… **éƒ¨ç½²çµæ´»**: æ”¯æŒæœ¬åœ°/Docker/äº‘éƒ¨ç½²

### æ”¹è¿›æ–¹å‘

1. **æµå¼å“åº”**: æ”¯æŒ Server-Sent Events
2. **åˆ†å¸ƒå¼ä¼šè¯**: Redis/PostgreSQL å­˜å‚¨
3. **å·¥ä½œæµå¼•æ“**: DAG ä»»åŠ¡ç¼–æ’
4. **å¯è§‚æµ‹æ€§**: Prometheus + Grafana ç›‘æ§
5. **å¤šæ¨¡æ€å¢å¼º**: è§†é¢‘/éŸ³é¢‘å¤„ç†

---

## ä¹ã€å®ç°ä¸Šä¸‹æ–‡

### ä½•æ—¶ä½¿ç”¨ nanobot

**é€‚åˆåœºæ™¯**:
- éœ€è¦å¿«é€ŸåŸå‹éªŒè¯ AI Agent æƒ³æ³•
- ä¸ªäºº/å°å›¢é˜Ÿ AI åŠ©æ‰‹éœ€æ±‚
- å­¦ä¹  LLM å·¥å…·è°ƒç”¨æœºåˆ¶
- ç ”ç©¶å¤š LLM æä¾›å•†é›†æˆ

**ä¸é€‚åˆåœºæ™¯**:
- ä¼ä¸šçº§é«˜å¹¶å‘ç”Ÿäº§ç¯å¢ƒ
- éœ€è¦å¤æ‚æƒé™ç®¡ç†ç³»ç»Ÿ
- å®æ—¶æµå¼å¯¹è¯éœ€æ±‚
- å¤šç§Ÿæˆ· SaaS æœåŠ¡

### æŠ€æœ¯é€‰å‹

**å¿…å¤‡çŸ¥è¯†**:
- Python 3.11+ å¼‚æ­¥ç¼–ç¨‹
- LLM API ä½¿ç”¨ï¼ˆOpenAI/Anthropicï¼‰
- åŸºç¡€ Linux è¿ç»´

**æ¨èå·¥å…·é“¾**:
- åŒ…ç®¡ç†: `uv` (å¿«é€Ÿ) æˆ– `pip`
- LLM æä¾›å•†: OpenRouterï¼ˆä¸€é”®è®¿é—®æ‰€æœ‰æ¨¡å‹ï¼‰
- æ¸ é“: Telegramï¼ˆæœ€ç®€å•ï¼‰
- éƒ¨ç½²: Docker Compose

### é›†æˆæ–¹å¼

**ä½œä¸ºåº“ä½¿ç”¨**:
```python
from nanobot.agent.loop import AgentLoop
from nanobot.providers.litellm_provider import LiteLLMProvider
from nanobot.bus.queue import MessageBus

bus = MessageBus()
provider = LiteLLMProvider(api_key="...", default_model="...")
agent = AgentLoop(bus, provider, workspace=Path("./workspace"))

# ç›´æ¥è°ƒç”¨
response = await agent.process_direct("Hello, world!")
```

**ä½œä¸ºæœåŠ¡éƒ¨ç½²**:
```bash
# Docker Compose
version: '3.8'
services:
  nanobot:
    image: nanobot:latest
    volumes:
      - ./config:/root/.nanobot
    ports:
      - "18790:18790"
    command: gateway
```

---

## åã€æœªæ¥å±•æœ›

### è·¯çº¿å›¾

| åŠŸèƒ½ | çŠ¶æ€ | ä¼˜å…ˆçº§ |
|-----|------|-------|
| âœ… è¯­éŸ³è½¬å½• | å·²å®Œæˆ (Groq Whisper) | - |
| ğŸ”„ å¤šæ¨¡æ€è¾“å…¥ | éƒ¨åˆ†æ”¯æŒï¼ˆå›¾ç‰‡ï¼‰ | é«˜ |
| ğŸ“‹ é•¿æœŸè®°å¿† | åŸºç¡€å®ç°ï¼ˆMarkdownï¼‰ | é«˜ |
| ğŸ§  æ¨ç†å¢å¼º | è§„åˆ’ä¸­ | ä¸­ |
| ğŸ“… æ—¥å†é›†æˆ | è§„åˆ’ä¸­ | ä¸­ |
| ğŸ” è‡ªæˆ‘æ”¹è¿› | ç ”ç©¶é˜¶æ®µ | ä½ |

### æŠ€æœ¯æ¼”è¿›æ–¹å‘

1. **Vector Database**: é›†æˆ ChromaDB/Qdrant å®ç°è¯­ä¹‰è®°å¿†
2. **Agent æ¡†æ¶**: æ”¯æŒ ReAct/MRKL ç­‰ç»å…¸èŒƒå¼
3. **å¤š Agent åä½œ**: ä¸»ä» Agent + ä¸“å®¶ Agent ç½‘ç»œ
4. **Web UI**: Streamlit/Gradio å¯è§†åŒ–ç•Œé¢

---

## å‚è€ƒæ¥æº

### é¡¹ç›®ä»“åº“
- **GitHub**: https://github.com/HKUDS/nanobot
- **PyPI**: https://pypi.org/project/nanobot-ai/

### ç›¸å…³æ–‡æ¡£
- **LiteLLM æ–‡æ¡£**: https://docs.litellm.ai/
- **OpenAI Function Calling**: https://platform.openai.com/docs/guides/function-calling
- **Anthropic Claude API**: https://docs.anthropic.com/

### çµæ„Ÿæ¥æº
- **Clawdbot**: https://github.com/openclaw/openclaw (å¯¹æ¯”é¡¹ç›®)
- **LangChain**: https://python.langchain.com/ (å·¥å…·è°ƒç”¨å‚è€ƒ)

---

**æœ€åæ›´æ–°**: 2026-02-10
**åˆ†ææ·±åº¦**: ä¸“å®¶çº§åˆ«
**ä»£ç è¦†ç›–**: 100% æ ¸å¿ƒæ¨¡å—
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
